# Copyright 2025 Tabs Data Inc.

import argparse
import importlib.metadata
import json
import os
import subprocess
from dataclasses import dataclass
from datetime import datetime
from importlib.resources import files
from typing import Any, Optional

import yaml


@dataclass
class PythonVersionParts:
    major: int
    minor: int
    patch: int


@dataclass
class PythonInstallation:
    key: str
    version: str
    version_parts: PythonVersionParts
    path: Optional[str]
    symlink: Optional[str]
    url: Optional[str]
    os: str
    variant: str
    implementation: str
    arch: str
    libc: str


class IndentDumper(yaml.Dumper):
    def increase_indent(self, flow=False, indentless=False):
        return super().increase_indent(flow, indentless=False)


def resolve_available_python_versions(etc: str, available_python_versions_file):
    result = subprocess.run(
        ["uv", "python", "list", "--all-versions", "--output-format", "json"],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
        check=True,
    )

    raw_json = json.loads(result.stdout)
    installations = []

    for entry in raw_json:
        if entry["implementation"] != "cpython":
            continue

        installation = PythonInstallation(
            key=entry["key"],
            version=entry["version"],
            version_parts=PythonVersionParts(**entry["version_parts"]),
            path=entry.get("path"),
            symlink=entry.get("symlink"),
            url=entry.get("url"),
            os=entry["os"],
            variant=entry["variant"],
            implementation=entry["implementation"],
            arch=entry["arch"],
            libc=entry["libc"],
        )
        installations.append(installation)

    installations.sort(
        key=lambda i: (
            i.version_parts.major,
            i.version_parts.minor,
            i.version_parts.patch,
        ),
        reverse=False,
    )

    versions = [v.version for v in installations]
    available_python_versions_path = os.path.join(etc, available_python_versions_file)

    with open(available_python_versions_path, "w", encoding="utf-8") as f:
        header = [
            "#",
            f"# Copyright {datetime.now().year} Tabs Data Inc. ",
            "#",
            " ",
            "# DO NOT EDIT THIS FILEÔ∏è",
            " ",
            "# Available Python Versions",
            " ",
            "# This file is automatically generated by the system at startup.",
            "# Any manual changes will be overwritten on the next restart.",
            "# Modifying this file may cause system instability or malfunction.",
            " ",
        ]
        data: dict[str, Any] = {"versions": versions}
        f.writelines(line + "\n" for line in header)
        yaml.dump(
            data,
            f,
            Dumper=IndentDumper,
            sort_keys=False,
            default_flow_style=False,
        )


def resolve_server_build_manifest(etc: str, server_build_manifest_file: str):
    sourcetrack_file = files("tabsdata.assets.manifest") / "SOURCETRACK.yaml"
    if not sourcetrack_file.is_file():
        server_sourcetrack = None
    else:
        server_sourcetrack = yaml.safe_load(
            sourcetrack_file.read_text(encoding="utf-8")
        )

    server_build_manifest_path = os.path.join(etc, server_build_manifest_file)

    header = [
        "#",
        f"# Copyright {datetime.now().year} Tabs Data Inc.",
        "#",
        " ",
    ]
    data = {"sourcetrack": server_sourcetrack}
    with open(server_build_manifest_path, "w", encoding="utf-8") as f:
        f.writelines(line + "\n" for line in header)
        yaml.dump(
            data,
            f,
            Dumper=IndentDumper,
            sort_keys=False,
            default_flow_style=False,
        )


def resolve_server_version(etc: str, server_version_file: str):
    # noinspection PyBroadException
    try:
        server_version = importlib.metadata.version("tabsdata")
    except Exception:
        server_version = "<unknown>"

    server_version_path = os.path.join(etc, server_version_file)

    header = [
        "#",
        f"# Copyright {datetime.now().year} Tabs Data Inc.",
        "#",
        " ",
    ]
    data = {"version": server_version}
    with open(server_version_path, "w", encoding="utf-8") as f:
        f.writelines(line + "\n" for line in header)
        yaml.dump(
            data,
            f,
            Dumper=IndentDumper,
            sort_keys=False,
            default_flow_style=False,
        )


def main():
    parser = argparse.ArgumentParser(
        description="Generate Python version-related files."
    )
    parser.add_argument(
        "--etc",
        type=str,
        required=True,
        help="Path to the server etc folder",
    )
    parser.add_argument(
        "--available-python-versions-file",
        type=str,
        required=True,
        help="File containing the available Python versions in the server.",
    )
    parser.add_argument(
        "--server-build-manifest-file",
        type=str,
        required=True,
        help="File containing the server current build manifest.",
    )
    parser.add_argument(
        "--server-version-file",
        type=str,
        required=True,
        help="File containing the server current version.",
    )
    args = parser.parse_args()

    resolve_available_python_versions(
        etc=args.etc,
        available_python_versions_file=args.available_python_versions_file,
    )
    resolve_server_build_manifest(
        etc=args.etc,
        server_build_manifest_file=args.server_build_manifest_file,
    )
    resolve_server_version(
        etc=args.etc,
        server_version_file=args.server_version_file,
    )


if __name__ == "__main__":
    main()
