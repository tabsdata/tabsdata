# Copyright 2025 Tabs Data Inc.

import argparse
import importlib.metadata
import json
import os
import subprocess
from dataclasses import dataclass
from datetime import datetime
from importlib.resources import files
from pathlib import Path
from typing import Any, Optional

import yaml
from packaging.version import parse as parse_version

from tabsdata.__spec import MIN_PYTHON_VERSION


@dataclass
class PythonVersionParts:
    major: int
    minor: int
    patch: int


@dataclass
class PythonInstallation:
    key: str
    version: str
    version_parts: PythonVersionParts
    path: Optional[str]
    symlink: Optional[str]
    url: Optional[str]
    os: str
    variant: str
    implementation: str
    arch: str
    libc: str


class IndentDumper(yaml.Dumper):
    def increase_indent(self, flow=False, indentless=False):
        return super().increase_indent(flow, indentless=False)


def resolve_available_python_versions(etc: str, available_python_versions_file: str):
    """
    Generate the etc file with all the CPython versions that the current uv version
    supports on the server.
    """
    result = subprocess.run(
        ["uv", "python", "list", "--all-versions", "--output-format", "json"],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
        check=True,
    )

    raw_json = json.loads(result.stdout)
    installations = []

    for entry in raw_json:
        if entry["implementation"] != "cpython":
            continue

        installation = PythonInstallation(
            key=entry["key"],
            version=entry["version"],
            version_parts=PythonVersionParts(**entry["version_parts"]),
            path=entry.get("path"),
            symlink=entry.get("symlink"),
            url=entry.get("url"),
            os=entry["os"],
            variant=entry["variant"],
            implementation=entry["implementation"],
            arch=entry["arch"],
            libc=entry["libc"],
        )
        installations.append(installation)

    installations.sort(
        key=lambda i: (
            i.version_parts.major,
            i.version_parts.minor,
            i.version_parts.patch,
        ),
        reverse=False,
    )

    versions = list(dict.fromkeys(v.version for v in installations))
    available_python_versions_path = os.path.join(etc, available_python_versions_file)

    with open(available_python_versions_path, "w", encoding="utf-8") as f:
        header = [
            "#",
            f"# Copyright {datetime.now().year} Tabs Data Inc. ",
            "#",
            " ",
            "# DO NOT EDIT THIS FILE️",
            " ",
            "# Available Python Versions",
            " ",
            "# This file is automatically generated by the system at startup.",
            "# Any manual changes will be overwritten on the next restart.",
            "# Modifying this file may cause system instability or malfunction.",
            " ",
        ]
        data: dict[str, Any] = {"versions": versions}
        f.writelines(line + "\n" for line in header)
        yaml.dump(
            data,
            f,
            Dumper=IndentDumper,
            sort_keys=False,
            default_flow_style=False,
        )


def resolve_valid_python_versions(
    etc: str,
    available_python_versions_file: str,
    allowed_python_versions_file: str,
    valid_python_versions_file: str,
):
    """
    Generate the etc file with all the Python versions that are available and that
    have been specified as allowed in the server configuration. If no allowed
    versions are specified, all available versions will be considered valid.
    """
    min_python_version = parse_version(MIN_PYTHON_VERSION)

    available_python_versions_path = os.path.join(etc, available_python_versions_file)
    allowed_python_versions_path = os.path.join(etc, allowed_python_versions_file)
    valid_python_versions_path = os.path.join(etc, valid_python_versions_file)

    available_python_versions = (
        set(
            (
                yaml.safe_load(
                    open(available_python_versions_path, "r", encoding="utf-8")
                )
                or {}
            ).get("versions", [])
        )
        if Path(available_python_versions_path).exists()
        else set()
    )

    allowed_python_versions = (
        set(
            (
                yaml.safe_load(
                    open(allowed_python_versions_path, "r", encoding="utf-8")
                )
                or {}
            ).get("versions", [])
        )
        if Path(allowed_python_versions_path).exists()
        else set()
    )

    valid_python_versions = sorted(
        (
            available_python_versions.intersection(allowed_python_versions)
            if allowed_python_versions
            else available_python_versions
        ),
        key=parse_version,
    )

    valid_python_versions = sorted(
        [
            valid_python_version
            for valid_python_version in valid_python_versions
            if parse_version(valid_python_version) >= min_python_version
        ],
        key=parse_version,
    )

    header = [
        "#",
        f"# Copyright {datetime.now().year} Tabs Data Inc.",
        "#",
        " ",
        "# DO NOT EDIT THIS FILE️",
        " ",
        "# Valid Python Versions",
        " ",
        "# This file is automatically generated by the system at startup.",
        "# Any manual changes will be overwritten on the next restart.",
        "# Modifying this file may cause system instability or malfunction.",
        " ",
    ]
    data = {"versions": valid_python_versions}
    with open(valid_python_versions_path, "w", encoding="utf-8") as f:
        f.writelines(line + "\n" for line in header)
        yaml.dump(
            data,
            f,
            Dumper=IndentDumper,
            sort_keys=False,
            default_flow_style=False,
        )


def resolve_server_build_manifest(etc: str, server_build_manifest_file: str):
    """
    Generate the etc file with the server build manifest, that includes references
    to the commit hashes, branches and tags (if any) used in the build the running
    distribution.
    """
    sourcetrack_file = files("tabsdata.assets.manifest") / "SOURCETRACK.yaml"
    if not sourcetrack_file.is_file():
        server_sourcetrack = None
    else:
        server_sourcetrack = yaml.safe_load(
            sourcetrack_file.read_text(encoding="utf-8")
        )

    server_build_manifest_path = os.path.join(etc, server_build_manifest_file)

    header = [
        "#",
        f"# Copyright {datetime.now().year} Tabs Data Inc.",
        "#",
        " ",
    ]
    data = {"sourcetrack": server_sourcetrack}
    with open(server_build_manifest_path, "w", encoding="utf-8") as f:
        f.writelines(line + "\n" for line in header)
        yaml.dump(
            data,
            f,
            Dumper=IndentDumper,
            sort_keys=False,
            default_flow_style=False,
        )


def resolve_server_version(etc: str, server_version_file: str):
    """Generate the etc file containing the current product version running
    on the server
    """
    # noinspection PyBroadException
    try:
        server_version = importlib.metadata.version("tabsdata")
    except Exception:
        server_version = "<unknown>"

    server_version_path = os.path.join(etc, server_version_file)

    header = [
        "#",
        f"# Copyright {datetime.now().year} Tabs Data Inc.",
        "#",
        " ",
    ]
    data = {"version": server_version}
    with open(server_version_path, "w", encoding="utf-8") as f:
        f.writelines(line + "\n" for line in header)
        yaml.dump(
            data,
            f,
            Dumper=IndentDumper,
            sort_keys=False,
            default_flow_style=False,
        )


def main():
    parser = argparse.ArgumentParser(
        description="Generate Python version-related files."
    )
    parser.add_argument(
        "--etc",
        type=str,
        required=True,
        help="Path to the server etc folder",
    )
    # It will be generated (created or overwritten) when executing this program.
    parser.add_argument(
        "--available-python-versions-file",
        type=str,
        required=True,
        help="File containing the available Python versions in the server.",
    )
    # It will read when executing this program. If existing, it is assumed to have
    # been created externally. The supervisor creates and empty template at startup
    # if unexisting.
    parser.add_argument(
        "--allowed-python-versions-file",
        type=str,
        required=True,
        help="File containing the allowed Python versions in the server.",
    )
    # It will be generated (created or overwritten) when executing this program.
    parser.add_argument(
        "--valid-python-versions-file",
        type=str,
        required=True,
        help="File containing the valid Python versions in the server.",
    )
    # It will be generated (created or overwritten) when executing this program.
    parser.add_argument(
        "--server-build-manifest-file",
        type=str,
        required=True,
        help="File containing the server current build manifest.",
    )
    # It will be generated (created or overwritten) when executing this program.
    parser.add_argument(
        "--server-version-file",
        type=str,
        required=True,
        help="File containing the server current version.",
    )
    args = parser.parse_args()

    resolve_available_python_versions(
        etc=args.etc,
        available_python_versions_file=args.available_python_versions_file,
    )
    resolve_valid_python_versions(
        etc=args.etc,
        available_python_versions_file=args.available_python_versions_file,
        allowed_python_versions_file=args.allowed_python_versions_file,
        valid_python_versions_file=args.valid_python_versions_file,
    )
    resolve_server_build_manifest(
        etc=args.etc,
        server_build_manifest_file=args.server_build_manifest_file,
    )
    resolve_server_version(
        etc=args.etc,
        server_version_file=args.server_version_file,
    )


if __name__ == "__main__":
    main()
