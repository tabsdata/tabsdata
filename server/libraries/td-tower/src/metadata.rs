//
//  Copyright 2024 Tabs Data Inc.
//

use crate::error::FromHandlerError;
use crate::extractors::{FromHandler, Input};
use crate::handler::Handler;
use std::collections::HashSet;
use std::fmt::Debug;
use std::hash::Hash;
use tokio::sync::Mutex;
use tracing::warn;

#[derive(Clone)]
pub struct MetadataType {
    /// Where it comes from.
    fn_type: String,
    /// The actual type.
    ty: String,
}

impl Debug for MetadataType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        format!("Fn Name [{}]: Type [{}]", self.fn_type, self.ty).fmt(f)
    }
}

impl Eq for MetadataType {}

impl PartialEq for MetadataType {
    fn eq(&self, other: &Self) -> bool {
        // We don't care about the fn_name to compare them, as it just adds context.
        self.ty == other.ty
    }
}

impl Hash for MetadataType {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.ty.hash(state);
    }
}

/// Metadata is used only for testing. It will store all the information we need while walking
/// through all the services in the tower. Services should add logic to store the information
/// in this struct. This is the only way of getting specific information from the service after
/// it has been converted to a ServiceBox (which makes the inner types opaque).
///
/// IMPORTANT: Tests using this should be marked with the `test_tower_metadata` feature, and
/// tests names should also start with test_tower_metadata.
///
/// Example:
/// ```
/// #[cfg(feature = "test_tower_metadata")]
/// {
///     use tower::{ServiceBuilder, ServiceExt};
///     use tabsdatalib::common::tower_service::default_services::{ServiceEntry, ServiceReturn};
///     use tabsdatalib::common::tower_service::extractors::{type_of_val, FromHandlerError, MetadataMutex};
///     use tabsdatalib::common::tower_service::from_fn::from_fn;
///
///     async fn test_layer_fn() -> Result<(), FromHandlerError> {
///         panic!("This will not not be called");
///     }
///
///     let service = ServiceBuilder::new()
///         .layer(ServiceEntry::default())
///         .layer(from_fn(test_layer_fn))
///         .service(ServiceReturn);
///
///     let response: MetadataMutex = service.raw_oneshot(()).await.unwrap();
///     let metadata = response.get();
///
///     assert_eq!(metadata.fn_names(), &vec![type_of_val(&test_layer_fn)]);
/// }
/// ```
#[derive(Debug)]
pub struct Metadata {
    /// Function names that have been called.
    fn_types: Vec<String>,
    /// Created types by the service.
    created_types: HashSet<MetadataType>,
    /// Used types by the service.
    used_types: HashSet<MetadataType>,
    /// There could be types created by a service and overwritten by another. This is just a warning.
    overwritten_types: HashSet<MetadataType>,
    /// There will always be only 1 missing type: the one that the service is input requires.
    missing_types: HashSet<MetadataType>,
    /// There will be at most 1 unused type: the one that the service is actually returning.
    unused_types: HashSet<MetadataType>,
}

impl Metadata {
    fn with_initial_types(created: &[String]) -> Self {
        let created_types = created
            .iter()
            .map(|c| MetadataType {
                fn_type: "InitialValues".to_string(),
                ty: c.clone(),
            })
            .collect();
        Self {
            fn_types: Vec::new(),
            created_types,
            used_types: HashSet::new(),
            overwritten_types: HashSet::new(),
            missing_types: HashSet::new(),
            unused_types: HashSet::new(),
        }
    }

    pub fn assert_service<I, O>(&self, fn_names: &[String]) {
        self.assert_fn_names(fn_names);
        self.assert_input(&Self::get_type_name::<I>());
        self.assert_output(&Self::get_type_name::<O>());

        if !self.overwritten_types.is_empty() {
            warn!(
                "The following types were created and overwritten: {:?}",
                self.overwritten_types
            );
        }
    }

    fn get_type_name<T>() -> Vec<String> {
        let type_name = type_of::<Input<T>>();
        if type_name == type_of::<Input<()>>() {
            Vec::new()
        } else {
            vec![type_name]
        }
    }

    fn assert_fn_names(&self, fn_names: &[String]) {
        if self.fn_types != fn_names {
            panic!(
                "Error checking Service layers.\
                \nFound the following layers: {:#?}.\
                \nExpected: {:#?}.",
                self.fn_types, fn_names
            );
        }
    }

    fn assert_input(&self, missing_types: &[String]) {
        let found_missing_types = self
            .missing_types
            .iter()
            .filter(|ty| !missing_types.contains(&ty.ty))
            .collect::<Vec<_>>();

        if !found_missing_types.is_empty() {
            panic!(
                "Error checking Input types. All Input types should be generated by other layers in \
                the Service, except the Service Request.\
                \nFound the following input missing types: {found_missing_types:#?}."
            );
        }
    }

    fn assert_output(&self, unused_types: &[String]) {
        let found_unused_types = self
            .unused_types
            .iter()
            .filter(|ty| !unused_types.contains(&ty.ty))
            .collect::<Vec<_>>();

        if !found_unused_types.is_empty() {
            panic!(
                "Error checking Result types. All Result types should be used by other layers in \
                the Service, except the Service Result.\
                \nFound the following output unused types: {found_unused_types:#?}."
            );
        }
    }
}

#[derive(Debug)]
pub struct MetadataMutex(Mutex<Metadata>);

impl Default for MetadataMutex {
    fn default() -> Self {
        MetadataMutex::with_initial_types(&[])
    }
}

impl MetadataMutex {
    pub fn with_initial_types(created: &[String]) -> Self {
        MetadataMutex(Mutex::new(Metadata::with_initial_types(created)))
    }

    // This is different from the other FromHandler implementations because it's not sync, as we
    // do not allow random fns to get it. It's only used for testing.
    pub fn from_handler(handler: &Handler) -> Result<Input<MetadataMutex>, FromHandlerError> {
        Input::<MetadataMutex>::from_handler(handler)
    }

    /// Consumes the `Metadata` instance and returns the inner `MetadataFields`.
    pub fn get(self) -> Metadata {
        self.0.into_inner()
    }

    /// Adds a function name to the metadata.
    pub async fn add_fn_name(&self, fn_name: impl Into<String>) {
        self.0.lock().await.fn_types.push(fn_name.into());
    }

    pub async fn created_type(&self, fn_name: impl Into<String>, ty: impl Into<String>) {
        let ty = ty.into();
        if ty == type_of::<Input<()>>() {
            // We don't care about unit types
            return;
        }

        let metadata_type = MetadataType {
            fn_type: fn_name.into(),
            ty,
        };
        let mut this = self.0.lock().await;
        if this.created_types.contains(&metadata_type) {
            this.overwritten_types.insert(metadata_type.clone());
        } else {
            this.created_types.insert(metadata_type.clone());
        }
        this.unused_types.insert(metadata_type.clone());
    }

    pub async fn used_type(&self, fn_name: impl Into<String>, ty: impl Into<String>) {
        let ty = ty.into();
        if ty == type_of::<Input<()>>() {
            // We don't care about unit types
            return;
        }

        let metadata_type = MetadataType {
            fn_type: fn_name.into(),
            ty,
        };
        let mut this = self.0.lock().await;
        this.used_types.insert(metadata_type.clone());
        this.unused_types.remove(&metadata_type);
        if !this.created_types.contains(&metadata_type) {
            this.missing_types.insert(metadata_type.clone());
        }
    }

    // Very special case. It only happens in a transaction commit.
    pub async fn remove_created(&self, fn_name: impl Into<String>, ty: impl Into<String>) {
        let mut this = self.0.lock().await;
        let metadata_type = MetadataType {
            fn_type: fn_name.into(),
            ty: ty.into(),
        };
        this.created_types.remove(&metadata_type);
    }
}

/// Wrapper of [`std::any::type_name_of_val`], giving control on how to stringify a fn name.
/// Returns the type name of the given value as a string.
pub fn type_of_val<T>(val: &T) -> String {
    std::any::type_name_of_val(val).to_string()
}

pub fn type_of<T>() -> String {
    std::any::type_name::<T>().to_string()
}

#[cfg(test)]
mod tests {
    use crate::extractors::Input;
    use crate::metadata::{MetadataMutex, type_of, type_of_val};

    #[tokio::test]
    async fn test_tower_metadata_add_fn_name() {
        let metadata = MetadataMutex::default();
        metadata.add_fn_name("test_fn".to_string()).await;
        let fields = metadata.get();
        assert_eq!(&fields.fn_types, &vec!["test_fn".to_string()]);
    }

    #[tokio::test]
    async fn test_tower_metadata_assert_service() {
        struct InputType;
        struct OutputType;

        let metadata = MetadataMutex::default();
        metadata.add_fn_name("test_fn".to_string()).await;
        metadata
            .created_type("fn1", type_of::<Input<OutputType>>())
            .await;
        metadata
            .used_type("fn2", type_of::<Input<InputType>>())
            .await;
        let fields = metadata.get();
        fields.assert_service::<InputType, OutputType>(&["test_fn".to_string()]);
    }

    #[tokio::test]
    async fn test_tower_metadata_type_of() {
        assert_eq!(type_of_val(&1), "i32");
        assert_eq!(type_of_val(&"string".to_string()), "alloc::string::String");

        struct CustomStruct;
        assert_eq!(
            type_of_val(&CustomStruct),
            "td_tower::metadata::tests::test_tower_metadata_type_of::{{closure}}::CustomStruct"
        );

        assert_eq!(
            type_of_val(&test_tower_metadata_type_of),
            "td_tower::metadata::tests::test_tower_metadata_type_of"
        );
    }
}
